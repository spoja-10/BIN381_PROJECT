---
title: "03_child_mortality"
output:
  word_document: default
  html_document: default
---

# Data Cleaning: Child Mortality Rates

## Load Libraries

```{r load_libs}
# Data manipulation
library(dplyr)
library(tidyr)
library(readr)
library(here)
library(purrr)
library(stringr)
library(knitr)

# Extras for cleaning and exploration
library(janitor)  # clean column names
library(visdat)   # visualize missingness
library(skimr)    # summary stats
library(ggplot2)  # visualizations

```

## Load Dataset

```{r load_data}
# Load the child mortality dataset
cmr_df <- read_csv(
  here("data", "raw", "child-mortality-rates_national_zaf.csv"),
  col_types = cols()  # suppress column guessing warnings
)

# Remove first metadata row if present
cmr_df <- cmr_df[-1, ]
rownames(cmr_df) <- NULL

cat("Dataset loaded successfully.\n")
cat("Dimensions:", dim(cmr_df), "\n")



```

## Initial Data Assessment

```{r data_assessment }
# Clean column names
cmr_df <- janitor::clean_names(cmr_df)

# Peek at structure
glimpse(cmr_df)

# Summary stats
skim(cmr_df)

# Visualize missingness
vis_miss(cmr_df)

```
Purpose: Check structure, summary statistics, and missingness.
Explanation: This gives an overview of column types, missing values, and potential issues before cleaning.


# Handle Duplicates

```{r}
cat("Exact duplicates:", sum(duplicated(cmr_df)), "\n")

cmr_df <- cmr_df %>% distinct()

cat("Dimensions after deduplication:", dim(cmr_df), "\n")


```

## Drop Redundant / Empty Columns

```{r redundant_empty_columns}
redundant_cols <- c(
  "iso3", "data_id", "dhs_country_code", "country_name", "survey_id",
  "indicator_id", "sdrid", "region_id", "survey_type", "level_rank",
  "denominator_weighted", "denominator_unweighted", "by_variable_label"
)

cmr_df <- cmr_df %>% select(-any_of(redundant_cols))

cat("Dimensions after removing redundant/empty columns:", dim(cmr_df), "\n")


```
Columns that were unnecessary or fully empty were dropped:

- Redundant columns included identifiers such as iso3, data_id, dhs_country_code, survey_id, etc.
## Convert Column Types

-   Ensure numeric, integer, and logical columns are typed correctly for analysis.

```{r convert_column_types}
# Define expected columns by type (snake_case!)
numeric_cols  <- c("value", "precision", "ci_low", "ci_high")
integer_cols  <- c("survey_year", "indicator_order", "characteristic_id",
                   "characteristic_order", "survey_year_label")
logical_cols  <- c("is_total", "is_preferred")

# Safe conversion function
safe_convert <- function(df, cols, fun) {
  existing <- cols[cols %in% colnames(df)]
  if(length(existing) > 0) {
    df <- df %>% mutate(across(all_of(existing), fun))
  }
  return(df)
}

cmr_df <- cmr_df %>%
  safe_convert(numeric_cols, as.numeric) %>%
  safe_convert(integer_cols, as.integer) %>%
  safe_convert(logical_cols, ~as.logical(as.integer(.)))

glimpse(cmr_df)

```

## Handle Missing Values

```{r handle_missing_values, cache=FALSE}
# 1. Remove empty columns
cmr_df <- cmr_df %>%
  select(where(~!all(is.na(.))))

# 2. Impute numeric with median
num_cols <- cmr_df %>% select(where(is.numeric)) %>% names()
cmr_df <- cmr_df %>%
  mutate(across(all_of(num_cols), ~ifelse(is.na(.), median(., na.rm = TRUE), .)))

# 3. Impute categorical with mode
cat_cols <- cmr_df %>% select(where(is.character)) %>% names()
impute_mode <- function(x) {
  ux <- na.omit(x)
  if(length(ux) == 0) return(NA_character_)
  names(sort(table(ux), decreasing = TRUE))[1]
}
cmr_df <- cmr_df %>%
  mutate(across(all_of(cat_cols), ~ifelse(is.na(.), impute_mode(.), .)))

# 4. Summary after handling missing values
missing_summary <- cmr_df %>%
  summarise(across(everything(), ~sum(is.na(.)))) %>%
  tidyr::pivot_longer(cols = everything(), names_to = "Variable", values_to = "Missing_Count")

missing_summary  # this will be rendered in knit



```


- Completely empty columns were removed.

- Numeric columns: NAs imputed with median.

- Categorical columns: NAs imputed with mode.

## Handle Outliers

```{r Outliers}
num_cols <- cmr_df %>% select(where(is.numeric))

outlier_bounds <- function(x) {
  qnt <- quantile(x, probs=c(0.25, 0.75), na.rm=TRUE)
  iqr <- diff(qnt)
  c(lower=qnt[1]-1.5*iqr, upper=qnt[2]+1.5*iqr)
}

bounds <- map(num_cols, outlier_bounds)

cmr_df <- cmr_df %>%
  mutate(across(where(is.numeric),
                ~pmin(pmax(., bounds[[cur_column()]]["lower"]),
                      bounds[[cur_column()]]["upper"])))

```

## Handle Noise / Special Values

```{r}
cmr_df <- cmr_df %>%
  mutate(across(where(is.numeric),
                ~ifelse(. < 0, median(., na.rm = TRUE), .)))

```

- Negative numeric values were replaced with the column median.

## Save the Cleaned Dataset

```{r save dataset}
# Save cleaned dataset to processed folder
write_csv(cmr_df, here("data", "processed", "child-mortality-rates_cleaned.csv"))

cat("Cleaned dataset saved successfully.\n")
cat("Dimensions:", dim(cmr_df), "\n")

```
